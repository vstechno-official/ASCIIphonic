<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>ASCIIphonic — Grid Music Painter</title>
</head>
<body>
<style>
:root {
  --bg-grad: linear-gradient(160deg, #050d1c, #0a0a0a);
  --btn-grad: linear-gradient(135deg, #ff3cac, #2ad6ff, #aaff00);
  --cell-glow: 0 0 12px rgba(255, 60, 172, 0.7);
  --ink: #fff;
  --ink-muted: #bbb;
}
html, body { height: 100%; margin: 0; font-family: 'Courier New', monospace; background: var(--bg-grad); color: var(--ink); }
.app { display: grid; place-items: center; min-height: 100%; padding: 1rem; }
.frame {
  display: grid; grid-template-rows: auto 1fr auto;
  width: min(1100px, 100%); height: min(88vh, 900px);
  background: rgba(20, 20, 25, 0.55); backdrop-filter: blur(18px) saturate(180%);
  border: 1px solid rgba(255, 255, 255, 0.06); border-radius: 18px;
  box-shadow: 0 0 30px rgba(0,0,0,0.6);
}
.toolbar {
  display: flex; flex-wrap: wrap; gap: .6rem; align-items: center; justify-content: space-between;
  padding: .6rem .8rem; border-bottom: 1px solid rgba(255,255,255,0.06);
}
.badge { padding: .4rem .8rem; border-radius: 12px; background: rgba(255,255,255,0.05); }
.badge .sub { font-size: .7rem; color: var(--ink-muted); }
.badge .title { font-weight: 700; font-size: .95rem; }
.controls { display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; }
button {
  border: none; border-radius: 9999px; padding: .55rem 1rem; font-weight: 700; font-family: 'Trebuchet MS', sans-serif;
  background: var(--btn-grad); background-size: 200% 200%;
  animation: gradientFlow 5s ease infinite; color: #fff; cursor: pointer;
  transition: transform .15s ease, opacity .15s ease, box-shadow .15s ease;
  position: relative; overflow: hidden;
}
button:after {
  content: ""; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%) scale(0);
  background: rgba(255,255,255,0.4); border-radius: 50%; width: 200%; height: 200%; opacity: 0;
  transition: transform 0.4s ease, opacity 0.4s ease;
}
button:active:after {
  transform: translate(-50%,-50%) scale(1); opacity: 1;
}
button:hover { transform: translateY(-2px) scale(1.02); box-shadow: 0 0 12px rgba(255,255,255,0.3); }
.ghost { background: rgba(255,255,255,0.08); animation: none; }
.note { color: var(--ink-muted); font-size: .8rem; }
.stage { position: relative; overflow: hidden; }
.pad { position: absolute; inset: 0; padding: 10px; }
#grid {
  display: grid; user-select: none; place-content: center;
}
.cell {
  display: flex; align-items: center; justify-content: center;
  min-width: 24px; min-height: 24px;
}
.cell > span { font-size: clamp(14px, 1.9vmin, 24px); line-height: 1; transition: transform .15s ease, color .3s ease, text-shadow .3s ease; }
.cell.active > span { transform: scale(1.2); color: #ff3cac; text-shadow: var(--cell-glow); }
.gridlines { position: absolute; inset: 0; pointer-events: none; opacity: .08; }
.footer { padding: .4rem; text-align: center; font-size: .8rem; background: rgba(255,255,255,0.05); border-top: 1px solid rgba(255,255,255,0.06); }
.footer a { color: #ff3cac; text-decoration: none; }
.doc-panel {
  padding: .6rem; font-size: .8rem; background: rgba(255,255,255,0.08); backdrop-filter: blur(6px);
  display: none; border-top: 1px solid rgba(255,255,255,0.06); line-height: 1.4;
}
.show-doc .doc-panel { display: block; }
@keyframes gradientFlow {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}
@media (max-width: 640px) {
  .toolbar { flex-direction: column; align-items: stretch; gap: .4rem; }
  .controls { flex-wrap: nowrap; overflow-x: auto; scrollbar-width: none; }
  .controls::-webkit-scrollbar { display: none; }
}
@media (pointer: coarse) {
  .cell { min-width: 36px; min-height: 36px; }
}
</style>
<div class="app">
  <div class="frame">
    <div class="toolbar">
      <div class="badge">
        <div class="sub">ASCIIphonic</div>
        <div id="themeName" class="title">Loading…</div>
      </div>
      <div class="controls">
        <button id="switchBtn">Switch Pattern</button>
        <button id="mixBtn">TuneMix</button>
        <button id="clearBtn" class="ghost">Clear</button>
        <span class="note">Recording:</span>
        <button id="recStart">Start</button>
        <button id="recStopWav" class="ghost" disabled>Stop & Save WAV</button>
        <button id="recStopMp3" class="ghost" disabled>Stop & Save MP3</button>
        <button id="docBtn" class="ghost">Docs</button>
      </div>
    </div>
    <div id="stage" class="stage">
      <div class="pad">
        <div id="grid"></div>
        <svg id="gridlines" class="gridlines"></svg>
      </div>
    </div>
    <div class="doc-panel">
      Tap or click on cells to create ASCII art and play notes. Position affects pitch variation. Use Switch Pattern to change sounds and symbols. TuneMix plays a random mashup of all themes. Record your creations and save as WAV or MP3. Works on desktop and mobile. 
    </div>
    <div class="footer">❤️ from <a href="https://github.com/vstechno-official" target="_blank">vstechno</a></div>
  </div>
</div>
<script src="https://unpkg.com/lamejs@1.2.0/lame.min.js"></script>
<script>
(() => {
  const THEMES = [
    { name: "Bubbles · C Pentatonic", chars: ["·",".","o","O","@","*"], semis:[0,2,4,7,9], rootHz:261.63, osc:"sine", color:"#ff3cac" },
    { name: "Waves · Dorian", chars: ["~","-","/","\\","=","_"], semis:[0,2,3,5,7,9,10], rootHz:220.0, osc:"triangle", color:"#2ad6ff" },
    { name: "Runes · Minor Pent.", chars: ["+","x","#","%","=","*"], semis:[0,3,5,7,10], rootHz:293.66, osc:"square", color:"#aaff00" },
    { name: "Arrows · Lydian", chars: ["<",">","^","v","|","-"], semis:[0,2,4,6,7,9,11], rootHz:246.94, osc:"sawtooth", color:"#ff8c00" }
  ];
  const PADDING = 10;
  let rows=20, cols=32, cell=22;
  let grid = [];
  let isDrawing = false, themeIndex = 0, charCursor = 0;
  const stage = document.getElementById('stage');
  const gridEl = document.getElementById('grid');
  const gridLines = document.getElementById('gridlines');
  const themeName = document.getElementById('themeName');
  const switchBtn = document.getElementById('switchBtn');
  const mixBtn = document.getElementById('mixBtn');
  const clearBtn = document.getElementById('clearBtn');
  const recStart = document.getElementById('recStart');
  const recStopWav = document.getElementById('recStopWav');
  const recStopMp3 = document.getElementById('recStopMp3');
  const docBtn = document.getElementById('docBtn');
  const frame = document.querySelector('.frame');
  let actx=null, masterGain=null, tapProcessor=null, recording=false, buffersL=[], buffersR=[];
  const ensureAudio = () => {
    if (!actx) {
      const Ctx = window.AudioContext || window.webkitAudioContext; actx = new Ctx();
      masterGain = actx.createGain(); masterGain.gain.value = 0.9; masterGain.connect(actx.destination);
      tapProcessor = actx.createScriptProcessor(2048, 2, 2);
      masterGain.connect(tapProcessor); tapProcessor.connect(actx.destination);
      tapProcessor.onaudioprocess = e => {
        if (!recording) return;
        buffersL.push(new Float32Array(e.inputBuffer.getChannelData(0)));
        buffersR.push(new Float32Array(e.inputBuffer.getChannelData(1)));
      };
    }
  };
  const semitoneToFreq = (rootHz, semi) => rootHz * Math.pow(2, semi / 12);
  const playNote = (freq, color) => {
    ensureAudio();
    const t = actx.currentTime;
    const osc = actx.createOscillator();
    osc.type = THEMES[themeIndex].osc;
    const g = actx.createGain();
    const A=0.01,D=0.18,S=0.12,R=0.08,peak=0.18;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(peak, t + A);
    g.gain.exponentialRampToValueAtTime(S, t + A + D);
    g.gain.exponentialRampToValueAtTime(0.0001, t + A + D + R + 0.05);
    osc.frequency.value = freq;
    osc.connect(g); g.connect(masterGain);
    osc.start(t); osc.stop(t + A + D + R + 0.08);
  };
  const pointToIndex = (x, y) => {
    const rect = stage.getBoundingClientRect();
    const c = Math.floor((x - rect.left - PADDING) / cell);
    const r = Math.floor((y - rect.top - PADDING) / cell);
    if (r < 0 || c < 0 || r >= rows || c >= cols) return -1;
    return { idx: r * cols + c, pos: {r, c} };
  };
  const placeAtIndex = (data) => {
    if (!data || data.idx < 0 || data.idx >= grid.length) return;
    const theme = THEMES[themeIndex];
    const variation = Math.floor((data.pos.r + data.pos.c) % theme.semis.length);
    const ch = theme.chars[(charCursor + variation) % theme.chars.length];
    const semi = theme.semis[(charCursor + variation) % theme.semis.length];
    const freq = semitoneToFreq(theme.rootHz, semi);
    if (grid[data.idx] === ch) return;
    grid[data.idx] = ch;
    charCursor++;
    renderCell(data.idx);
    playNote(freq, theme.color);
    gridEl.children[data.idx].classList.add('active');
    setTimeout(()=>gridEl.children[data.idx].classList.remove('active'), 200);
  };
  function renderAll(){
    const rect = stage.getBoundingClientRect();
    const usableW = Math.max(0, rect.width - PADDING*2);
    const usableH = Math.max(0, rect.height - PADDING*2);
    cell = Math.max(14, Math.min(32, Math.floor(usableW / (rect.width < 640 ? 18 : rect.width < 1024 ? 26 : 32))));
    cols = Math.max(4, Math.floor(usableW / cell));
    rows = Math.max(4, Math.floor(usableH / cell));
    grid = Array(rows * cols).fill(' ');
    gridEl.style.gridTemplateColumns = `repeat(${cols}, ${cell}px)`;
    gridEl.style.gridTemplateRows = `repeat(${rows}, ${cell}px)`;
    gridEl.innerHTML = '';
    const frag = document.createDocumentFragment();
    for (let i=0;i<rows*cols;i++){
      const d = document.createElement('div'); d.className='cell';
      const s = document.createElement('span'); s.textContent = ' ';
      d.appendChild(s); frag.appendChild(d);
    }
    gridEl.appendChild(frag);
    renderGridLines();
    themeName.textContent = THEMES[themeIndex].name;
    charCursor = 0;
  }
  function renderCell(idx){
    const cellEl = gridEl.children[idx]; if(!cellEl) return;
    cellEl.firstChild.textContent = grid[idx];
  }
  function renderGridLines(){
    gridLines.setAttribute('viewBox', `0 0 ${cols*cell} ${rows*cell}`);
    gridLines.innerHTML = '';
    for (let i=0;i<=cols;i++){
      const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
      ln.setAttribute('x1', i*cell); ln.setAttribute('y1', 0);
      ln.setAttribute('x2', i*cell); ln.setAttribute('y2', rows*cell);
      ln.setAttribute('stroke', '#fff'); ln.setAttribute('stroke-width', '1');
      gridLines.appendChild(ln);
    }
    for (let i=0;i<=rows;i++){
      const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
      ln.setAttribute('x1', 0); ln.setAttribute('y1', i*cell);
      ln.setAttribute('x2', cols*cell); ln.setAttribute('y2', i*cell);
      ln.setAttribute('stroke', '#fff'); ln.setAttribute('stroke-width', '1');
      gridLines.appendChild(ln);
    }
  }
  const mergeFloat = bufs => {
    const len = bufs.reduce((n,b)=>n+b.length,0);
    const out = new Float32Array(len); let o=0;
    for (const b of bufs){ out.set(b, o); o+=b.length; }
    return out;
  };
  const floatTo16 = f32 => {
    const out = new Int16Array(f32.length);
    for(let i=0;i<f32.length;i++){ const s=Math.max(-1,Math.min(1,f32[i])); out[i] = (s<0 ? s*32768 : s*32767)|0; }
    return out;
  };
  const interleaveLR = (L,R) => {
    const n=L.length; const out=new Int16Array(n*2);
    for(let i=0,j=0;i<n;i++,j+=2){ out[j]=L[i]; out[j+1]=R[i]; }
    return out;
  };
  const exportWav = (sampleRate, bufsL, bufsR) => {
    const L = floatTo16(mergeFloat(bufsL)), R=floatTo16(mergeFloat(bufsR));
    const inter = interleaveLR(L,R); const bytes = inter.length * 2;
    const buffer = new ArrayBuffer(44 + bytes);
    const view = new DataView(buffer);
    const writeStr=(o,s)=>{ for(let i=0;i<s.length;i++) view.setUint8(o+i, s.charCodeAt(i)); };
    writeStr(0,'RIFF'); view.setUint32(4, 36+bytes, true); writeStr(8,'WAVE'); writeStr(12,'fmt ');
    view.setUint32(16,16,true); view.setUint16(20,1,true); view.setUint16(22,2,true); view.setUint32(24,sampleRate,true);
    view.setUint32(28,sampleRate*4,true); view.setUint16(32,4,true); view.setUint16(34,16,true);
    writeStr(36,'data'); view.setUint32(40, bytes, true);
    let o=44; for(let i=0;i<inter.length;i++,o+=2) view.setInt16(o, inter[i], true);
    return new Blob([view], {type:'audio/wav'});
  };
  const exportMp3 = (sampleRate, bufsL, bufsR) => {
    const L = floatTo16(mergeFloat(bufsL)), R=floatTo16(mergeFloat(bufsR));
    const enc = new lamejs.Mp3Encoder(2, sampleRate, 128);
    const BLOCK=1152; const out=[]; 
    for(let i=0;i<L.length;i+=BLOCK){ const bufL=L.subarray(i,i+BLOCK); const bufR=R.subarray(i,i+BLOCK); const mp3buf = enc.encodeBuffer(bufL, bufR); if(mp3buf.length) out.push(new Int8Array(mp3buf)); }
    const end = enc.flush(); if(end.length) out.push(new Int8Array(end));
    return new Blob(out, {type:'audio/mpeg'});
  };
  const downloadBlob = (blob, filename) => {
    const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 1000);
  };
  function handleDown(x,y){ isDrawing=true; placeAtIndex(pointToIndex(x,y)); }
  function handleMove(x,y){ if(!isDrawing) return; placeAtIndex(pointToIndex(x,y)); }
  function handleUp(){ isDrawing=false; }
  stage.addEventListener('mousedown', e=>{ handleDown(e.clientX, e.clientY); });
  window.addEventListener('mousemove', e=>{ handleMove(e.clientX, e.clientY); });
  window.addEventListener('mouseup', handleUp);
  stage.addEventListener('touchstart', e=>{ const t=e.touches[0]; handleDown(t.clientX, t.clientY); e.preventDefault(); }, {passive:false});
  window.addEventListener('touchmove', e=>{ const t=e.touches[0]; handleMove(t.clientX, t.clientY); e.preventDefault(); }, {passive:false});
  window.addEventListener('touchend', handleUp);
  switchBtn.addEventListener('click', ()=>{ themeIndex = (themeIndex+1) % THEMES.length; themeName.textContent = THEMES[themeIndex].name; charCursor = 0; });
  mixBtn.addEventListener('click', ()=>{ 
    for(let i=0;i<20;i++){
      setTimeout(()=>{
        const theme = THEMES[Math.floor(Math.random()*THEMES.length)];
        const semi = theme.semis[Math.floor(Math.random()*theme.semis.length)];
        const freq = semitoneToFreq(theme.rootHz, semi);
        playNote(freq, theme.color);
      }, i*100);
    }
  });
  clearBtn.addEventListener('click', ()=>{ grid.fill(' '); for(let i=0;i<grid.length;i++) renderCell(i); charCursor=0; });
  recStart.addEventListener('click', ()=>{ ensureAudio(); buffersL=[]; buffersR=[]; recording = true; recStopWav.disabled=false; recStopMp3.disabled=false; });
  recStopWav.addEventListener('click', ()=>{ if(!actx) return; recording=false; const blob = exportWav(actx.sampleRate, buffersL, buffersR); downloadBlob(blob, `ASCIIphonic-${Date.now()}.wav`); recStopWav.disabled=true; recStopMp3.disabled=true; });
  recStopMp3.addEventListener('click', ()=>{ if(!actx) return; if(!window.lamejs){ alert('MP3 encoder not loaded; falling back to WAV.'); recStopWav.click(); return; } recording=false; const blob = exportMp3(actx.sampleRate, buffersL, buffersR); downloadBlob(blob, `ASCIIphonic-${Date.now()}.mp3`); recStopWav.disabled=true; recStopMp3.disabled=true; });
  docBtn.addEventListener('click', ()=>{ frame.classList.toggle('show-doc'); });
  const ro = new ResizeObserver(()=>renderAll()); ro.observe(stage);
  renderAll();
})();
</script>
</body>
</html>
<!--@https://github.com/vstechno-official-->